重建二叉树

题目描述
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}
	  和中序遍历序列{4,7,2,1,5,3,8,6}，
则重建二叉树并返回。

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* ConstructCore(vector<int>& pre,vector<int>& vin){
        // 获取根节点
        // 初始化根节点
        int rootValue = pre[0];
        TreeNode* root = (TreeNode*) malloc (sizeof(TreeNode));
        root->val = rootValue;
        root->left = root->right = NULL;
        // 如果 数组为 0 返回 NULL
        if(pre.size() == 0 && vin.size() == 0){
            return root;
        }
        
        // 获取中序遍历中 根节点前的长度
        // 这个长度 是左子树的个数
        size_t left_len = 0;
        while(vin[left_len] != rootValue && left_len < vin.size()){
            left_len++;
        }
        
        if(left_len == vin.size()){
            return NULL;
        }
        
        // 左子树的前序遍历
        vector<int> left_pre;
        // 右子树的前序遍历
        vector<int> right_pre;
        // 左子树的中序遍历
        vector<int> left_vin;
        // 右子树的中序遍历
        vector<int> right_vin;
        
        // 前序遍历的 [1,len+1) 是左子树前序遍历个数
        for(int i = 0; i < left_len; ++i){
            left_pre.push_back(pre[i+1]);
        }
        // 前序遍历的 [len,pre.size()) 是右子树的前序遍历
        for(int i = left_len+1; i < pre.size();++i){
            right_pre.push_back(pre[i]);
        }
        // 中序遍历的 [0,len) 是左子树的中序遍历
        for(int i = 0; i < left_len; ++i){
            left_vin.push_back(vin[i]);
        }
        // 中序遍历的 [len+1, vin .size()) 是右子树的中序遍历
        for(int i = left_len + 1; i < vin.size(); ++i){
            right_vin.push_back(vin[i]);
        }
        // 如果左子树存在 向左递归
        if(left_pre.size() > 0 && left_vin.size() > 0){
            root->left = ConstructCore(left_pre,left_vin);
        }
        // 如果右子树存在 向右递归
        if(right_pre.size() > 0 && right_vin.size() > 0){
            root->right = ConstructCore(right_pre,right_vin);
        }
        return root;
    }
    
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.size() <= 0 && vin.size() <= 0){
            return NULL;
        }
        return ConstructCore(pre,vin);
    }
};